---
author: CC-2018
layout: post
title: "python基础(二)"
date: 2017-06-26 21:08:01 +0800
categories: document
tag: 教程
---

* content
{:toc}

本片文章记录python一些特性和用法。

### 高阶函数

和js里面一样，函数可以赋值给一个变量：
```
>>> f = abs
>>> f(-10)
10
```

也可以当作参数：
```
def add(x, y, f):
    return f(x) + f(y)
```
这种函数称之为高阶函数，如`add`。

**map/reduce/filter/sorted**

这里的map非数据结构map，而是一种高阶函数：

```
>>> def f(x):
...     return x * x
...
>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]
```

map是将一个函数诸葛作用在list的元素上，结果r是一个迭代器Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：

```
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
```

比如一个map/reduce的`str2int`例子（字符串也是一个list）:

```
from functools import reduce

def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]
    return reduce(fn, map(char2num, s))
```

用lambda函数进一步简化成：

```
from functools import reduce

def char2num(s):
    return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]

def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
```

filter的作用是把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素：

```
def is_odd(n):
...    return n % 2 == 1
...
>>> list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
[1, 5, 9, 15]
```

sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：

```
>>> sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
```

### 函数式编程
函数作为返回值：

```
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
>>> f = lazy_sum(1, 3, 5, 7, 9)
>>> f()
```

lazy_sum 每次返回的是一个新的函数对象，而且lazy_sum里使用了闭包的功能，共享参数args。

匿名函数：
```
>>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[1, 4, 9, 16, 25, 36, 49, 64, 81]
```
实际上相当于：
```
def f(x):
    return x * x
```

关键字lambda表示匿名函数，冒号前面的x表示函数参数。
```
>>> f = lambda x, y: x * y
>>> f(2, 3)
6
```

将匿名函数当作返回值，生成一个新函数
```
def build(x, y):
    return lambda: x * x + y * y
```

装饰器

在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator），本质上，decorator就是一个返回函数的高阶函数。
```
def log(text):
    def wrapper(*args, **kw):
        print('%s %s():' % (text, func.__name__))
        return func(*args, **kw)
    return wrapper

@log
def now():
    print('2017-06-26')

>>> now()
call now():
2017-06-26
```

把`@log`放到`now()`函数的定义处，相当于执行了语句：`now = log(now)`, 现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。


再定义带参数的装饰器：
```
def log(text):
    def decorator(func):
        # 更改函数名称__name__使用
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator

@log('execute')
def now():
    print('2017-06-26')

>>> now()
execute now():
2017-06-26
```

执行装饰器相当于：`now = log('execute')(now)`

偏函数
```
>>> import functools
>>> int2 = functools.partial(int, base=2)
>>> int2('1000000')
64
>>> int2('1010101')
85
>>> int2('1000000', base=10)
1000000
```

functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，简化函数调用。

---
本文大部分内容来自廖雪峰老师的[Python教程](http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000)，记录在此只为个人记忆和时常快速翻阅。
